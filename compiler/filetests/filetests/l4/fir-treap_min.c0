
/*
(
 (kind(CompileAndRun))
)
*/

struct twister_t {
  int index;
  int[] states;
};

typedef twister_t struct twister_t;

struct treap_node_t {
 struct treap_node_t * left;
 struct treap_node_t * right;
 struct treap_node_t * parent;
  int prio;
 int key;
 int value;
};

typedef treap_node_t struct treap_node_t;

struct treap_t {
 twister_t * random;
 treap_node_t * root;
};

typedef treap_t struct treap_t;

extern void c0_runtime_print_int(int n);
void printint(int n) {
    c0_runtime_print_int(n);
}
extern void c0_runtime_print_char(int n);
void printchar(int c) {
    c0_runtime_print_int(c);
}

twister_t *twister_alloc(int seed)
{
  twister_t * twister;
  int[] states;
  int i;
  twister = alloc(twister_t);

  states = alloc_array(int, 624);
  twister->states = states;

  states = twister->states;
  states[0] = seed;
  for(i = 1; i <= 623; i += 1)
  {
      states[i] = (1812433253 * (states[i-1] ^ (states[i-1] >> 30 )) + i) ;
  }
  return twister;
}

int twister_gen(twister_t * twister)
{
  int i,y;
  int[] states;
  states = twister->states;
  for(i = 0; i <= 623; i += 1)
  {
    y = ((((states[i])) & (1 << (31))) != 0 ? 1 : 0) + (~(1 << (31)) & (states[(i+1) % 624]));
    states[i] = states[(i + 397) % 624] ^ (y >> 1);
    if((y % 2) == 1)
    {

      states[i] = states[i] ^ (2567483615) ;
    }
  }
  return 0;
}

int twister_rand(twister_t * twister) {
  int y;
  int unit;
  if(twister->index == 0)
  {
    unit = twister_gen(twister);
  }

  y = twister->states[twister->index];
    y ^= (y >> 11);
    y ^= (y << 7) & (2636928640) ;
    y ^= (y << 15) & (4022730752) ;
    y ^= (y >> 18);

    twister->index = (twister->index + 1) % 624;
    return y;
}

twister_t *twister_new(int seed)
{
  twister_t *twister;
  int[] states;
  int i;
  twister = alloc(twister_t);
  states = alloc_array(int, 624);
  twister->states = states;

  states = twister->states;
  states[0] = seed;
  for (i = 1; i <= 623; i += 1)
  {
      states[i] = (1812433253 * (states[i-1] ^ (states[i-1] >> 30 )) + i) ;
  }
  return twister;
}

treap_t *treap_create(int seed)
{
    treap_t * trp;
  trp = alloc(treap_t);
  trp->root = null;
  trp->random = twister_new(seed);
    return trp;
}

int treap_rotate_right(treap_t * trp, treap_node_t * node)
{
  treap_node_t * left,parent;
  parent = node->parent;
  left = node->left;
  node->left = left->right;
  left->parent = parent;
  node->parent = left;
  left->right = node;

  if(parent != null)
  {
    if(parent->left == node)
    {
      parent->left = left;
    }
    else
    {
      parent->right = left;
    }
  }
  else
  {

    trp->root = left;
  }
  if(node->left != null)
  {
    node->left->parent = node;
  }
  return 0;
}
int treap_rotate_left(treap_t * trp, treap_node_t * node)
{
    treap_node_t * right,parent;
  parent = node->parent;
  right = node->right;
  node->right = right->left;
  right->parent = parent;
  node->parent = right;
  right->left = node;

    if(parent != null)
    {
      if(parent->right == node)
      {
        parent->right = right;
      }
      else
      {
        parent->left = right;
      }
    }
    else
    {

      trp->root = right;
    }
  if(node->right != null)
  {
   node->right->parent = node;
  }
  return 0;
}
int treap_get_min(treap_t * trp, int * key, int * value)
{
 treap_node_t * left,temp;
 temp = trp->root;
 left = temp;
 if(temp == null)
 {
  return -1;
 }
 while(temp != null)
 {
  left = temp;
  temp = left->left;
 }
 *key = left->key;
 *value = left->value;
 return 0;
}
int treap_percolate_up(treap_t * trp, treap_node_t * node)
{
  treap_node_t * parent;
  parent = node->parent;
  while((parent != null)
          && (((node)->prio) < ((parent)->prio)))
  {

    if(parent->left == node)
    {
      treap_rotate_right(trp, parent);


    }
    else if(parent->right == node)
    {
      treap_rotate_left(trp, parent);


    }
   parent = node->parent;
  }
  return 0;
}

int treap_percolate_down(treap_t * trp, treap_node_t * node)
{
  treap_node_t * left,right;
  left = node->left;
  right = node->right;
  while(left != null || right != null)
  {
    if(left == null)
    {
     treap_rotate_left(trp, node);
    }
    else if(right == null)
    {
      treap_rotate_right(trp, node);
    }
    else if((((left)->prio) < ((right)->prio)))
    {
      treap_rotate_right(trp, node);
    }
    else
    {
      treap_rotate_left(trp, node);
    }
    left = node->left;
    right = node->right;
  }
  return 0;
}







int treap_insert(treap_t * trp, int key, int value)
{
  treap_node_t * temp,parent,new_node;
  temp = trp->root;
  parent = temp;
  new_node = alloc(treap_node_t);

  new_node->prio = twister_rand(trp->random);
  new_node->key = key;
  new_node->value = value;
  new_node->left = null;
  new_node->right = null;
  new_node->parent = null;


  while(temp != null)
  {
    parent = temp;
    if(new_node->key < parent->key)
    {
      temp = parent->left;
    }
    else
    {
      temp = parent->right;
    }
  }
  if(parent == null)
  {
    trp->root = new_node;
    return 0;
  }
  if(new_node->key < parent->key)
  {
    parent->left = new_node;
  }
  else
  {
    parent->right = new_node;
  }
  new_node->parent = parent;
  treap_percolate_up(trp, new_node);
  if(new_node->parent == null)
  {
    trp->root = new_node;
  }
  return 0;
}
int treap_remove(treap_t * trp, int key, int * value)
{
  treap_node_t * temp;
  temp = trp->root;
  while((temp != null) && (temp->key != key))
  {
    if(temp->key > key)
    {
      temp = temp->left;
    }
    else if(temp->key < key)
    {
      temp = temp->right;
    }
  }
  if(temp == null)
  {

    return -1;
  }
  *value = temp->value;
  treap_percolate_down(trp, temp);
  if(temp->parent != null)
  {
    if(temp->parent->left == temp)
    {
      temp->parent->left = null;
    }
    else
    {
      temp->parent->right = null;
    }
 }
  else
  {
    trp->root = null;
  }
  return 0;
}







int treap_lookup(treap_t * trp, int key, int * value)
{
    treap_node_t * temp;
    temp = trp->root;
    while((temp != null) && (temp->key != key))
    {

        if(temp->key > key)
        {
            temp = temp->left;
        }
        else if(temp->key < key)
        {
            temp = temp->right;
        }
    }
    if(temp == null)
    {
        return -1;
    }
    *value = temp->value;
    return 0;
}




int treap_empty(treap_t * trp)
{
    if(trp->root == null)
    {
        return 1;
    }
    else
    {
        return 0;
    }

}
int treap_print_node(treap_node_t * node)
{
 printchar(107);
 printchar(61);
 printint(node->key);
 printchar(44);
 printchar(32);
 printchar(112);
 printchar(61);
 printint(node->prio);
 printchar(44);
 printchar(32);
 printchar(118);
 printchar(61);
 printint(node->value);
 printchar(10);
 return 0;
}




int print_ins(int k, int v)
{
 printchar(73);
 printchar(78);
 printchar(83);
 printchar(32);
 printchar(107);
 printchar(61);
 printint(k);
 printchar(44);
 printchar(32);
 printchar(118);
 printchar(61);
 printint(v);
 printchar(10);
 return 0;
}

void main()
{
 treap_t * trp;
 twister_t * random;
 int * ret,ret2;
 int idx,num,idx2;
 int[] nums;
 ret = alloc(int);
 ret2 = alloc(int);
 nums = alloc_array(int, 50);
 random = twister_alloc(8151337);

 trp = treap_create(-876543);

 for(idx = 0; idx < 50; idx += 1)
 {
  nums[idx] = twister_rand(random);
  treap_insert(trp, nums[idx], idx);
 }

 treap_get_min(trp, ret, ret2);
 c0_runtime_print_int(*ret);
}
----
210641484554142582
