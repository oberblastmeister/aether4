/*
(
 (kind(CompileAndRun))
)
*/


extern int c0_runtime_print_char(int c);


// extern int abs(int x);

// construct all n-queens solutions

int abs(int x) {
  return x >= 0 ? x : -x;
}

bool isSolution(int[] a, int k, int n) {
  return k == n;
}

int constructCandidates(int[] a, int k, int n, int[] c) {
  int i, j, nc;
  bool legal;

  nc = 0;
  for(i = 1; i <= n; i += 1) {
    legal = true;
	for(j = 1; j < k; j += 1) {
      // diagonal threat
	  if(abs(k - j) == abs(i - a[j]))
	    legal = false;
      // column threat
	  if(i == a[j])
	    legal = false;
	}
	if(legal) {
	  c[nc] = i;
	  nc += 1;
	}
  }
  
  return nc;
}

int processSolution(int[] a, int k) {
  int i;
  
  c0_runtime_print_char(40);
  c0_runtime_print_char(32);
  for(i = 1; i <= k; i += 1) {
      c0_runtime_print_char(48 + a[i]);
	  c0_runtime_print_char(32);
  }
  c0_runtime_print_char(41);
  c0_runtime_print_char(10);
  
  return 0;
}

// general backtracking algorithm

int backtrack(int[] a, int k, int n) {
  int[] c;
  int i, ncandidates, MAX_CANDIDATES, solutions;
  
  solutions = 0;
  MAX_CANDIDATES = n;
  c = alloc_array(int, MAX_CANDIDATES);
  
  if(isSolution(a, k, n)) {
    processSolution(a, k);
	solutions = 1;
  }
  else {
    k += 1;
	ncandidates = constructCandidates(a, k, n, c);
	for(i = 0; i < ncandidates; i += 1) {
	  a[k] = c[i];
	  solutions += backtrack(a, k, n);
	}
  }
  return solutions;
}

void main(){
  int[] a;
  int n;
  
  n = 7;
  a = alloc_array(int, n + 1);
  
  assert(backtrack(a, 0, n) == 40);
}
----
( 1 3 5 7 2 4 6 )
( 1 4 7 3 6 2 5 )
( 1 5 2 6 3 7 4 )
( 1 6 4 2 7 5 3 )
( 2 4 1 7 5 3 6 )
( 2 4 6 1 3 5 7 )
( 2 5 1 4 7 3 6 )
( 2 5 3 1 7 4 6 )
( 2 5 7 4 1 3 6 )
( 2 6 3 7 4 1 5 )
( 2 7 5 3 1 6 4 )
( 3 1 6 2 5 7 4 )
( 3 1 6 4 2 7 5 )
( 3 5 7 2 4 6 1 )
( 3 6 2 5 1 4 7 )
( 3 7 2 4 6 1 5 )
( 3 7 4 1 5 2 6 )
( 4 1 3 6 2 7 5 )
( 4 1 5 2 6 3 7 )
( 4 2 7 5 3 1 6 )
( 4 6 1 3 5 7 2 )
( 4 7 3 6 2 5 1 )
( 4 7 5 2 6 1 3 )
( 5 1 4 7 3 6 2 )
( 5 1 6 4 2 7 3 )
( 5 2 6 3 7 4 1 )
( 5 3 1 6 4 2 7 )
( 5 7 2 4 6 1 3 )
( 5 7 2 6 3 1 4 )
( 6 1 3 5 7 2 4 )
( 6 2 5 1 4 7 3 )
( 6 3 1 4 7 5 2 )
( 6 3 5 7 1 4 2 )
( 6 3 7 4 1 5 2 )
( 6 4 2 7 5 3 1 )
( 6 4 7 1 3 5 2 )
( 7 2 4 6 1 3 5 )
( 7 3 6 2 5 1 4 )
( 7 4 1 5 2 6 3 )
( 7 5 3 1 6 4 2 )
