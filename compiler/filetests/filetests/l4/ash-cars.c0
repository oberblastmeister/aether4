/*
(
 (kind(CompileAndRun))
)
*/


extern void c0_runtime_print_int(int a);
extern void c0_runtime_print_char(int a);

void printint(int i) {
    c0_runtime_print_int(i);
}

void printchar(int i) {
    c0_runtime_print_char(i);
}

struct List {
  int head;
  struct List* tail;
};

typedef List struct List;

/* basic list */

List* nil() {
  return null;
}

List* cons(int i, List* list) {
  List* newList;
  newList = alloc(List);
  newList->head = i;
  newList->tail = list;
  return newList;
}

bool isEmpty(List* list) {
  return list == null;
}


int first(List** street) {
  return(*street)->head;
}

int enqueue(int car, List** street) {
  *street = cons(car, *street);
  return 0;
}
int dequeue(List** street) {
  *street = (*street)->tail;
  return 0;
}

/* list manipulation */ 

int foldLeft_int(int z, List* list, int funselect) {
  while(!isEmpty(list)) {
    // length
    if(funselect == 1)
	  z += 1;
	// onlyZeroes
	else if(funselect == 2)
	  z = (z != 0) && (list->head == 0) ? 1 : 0;
	//  sum
	else if(funselect == 3)
	  z += list->head;
	// ...
	
	list = list->tail;
  }
  return z;
}


List* foldLeft_List(List* z, List* list, int funselect) {
  while(!isEmpty(list)) {
    // reverse
    if(funselect == 1)
	  z = cons(list->head, z);
	//  ...
	
	list = list->tail;
  }
  return z;
}

List* reverse(List* list) {
  return foldLeft_List(nil(), list, 1);
}

List* concatRev(List* frontRev, List* back) {
  return foldLeft_List(back, frontRev, 1);
}

List* concat(List* front, List* back) {
  return concatRev(reverse(front), back);
}

/*  list analysis */

int length(List* list) {
  return foldLeft_int(0, list, 1);
}

int onlyZeroes(List* list) {
  return foldLeft_int(1, list, 2);
}

int sum(List* list) {
  return foldLeft_int(0, list, 3);
}

bool isSorted(List* list) {
  int min;
  min = -2147483648;
  while(!isEmpty(list)) {
    if(list->head < min) return false;
    else min = list->head;
    list = list->tail;
  }
  return true; 
}

bool equal(List* as, List* bs) {
  return(isEmpty(as) == isEmpty(bs)) && (isEmpty(as) || (as->head == bs->head && equal(as->tail, bs->tail)));
} 

/* list creation */

// list [start, ..., end)
List* range(int start, int end) {
  if(start < end)
    return cons(start, range(start + 1, end));
  else
    return nil();
}

// list [1, ..., end]
List* upto(int end) {
  return range(1, end + 1);
}

// solves the 'cars' problem

void main() {
  int next, test;
  List** streetIN, streetOUT, streetWAIT;
  
  // init
  streetIN = alloc(List*);
  streetOUT = alloc(List*);
  streetWAIT = alloc(List*);
  *streetIN = cons(8, cons(7, cons(1, cons(4, cons(3, cons(2, cons(6, cons(5, nil()))))))));
  *streetOUT = nil();
  *streetWAIT = nil();
  
  // solve
  for(next = 1; next < 9;) {
    printint(length(*streetIN));
	printint(length(*streetWAIT));
    printint(length(*streetOUT));
	printchar(10);
	
    if(!isEmpty(*streetIN) && first(streetIN) == next) {
	  enqueue(first(streetIN), streetOUT);
	  dequeue(streetIN);
	  next += 1;
	}
	else if(!isEmpty(*streetWAIT) && first(streetWAIT) == next) {
	  enqueue(first(streetWAIT), streetOUT);
	  dequeue(streetWAIT);
	  next += 1;
	}
	else if(!isEmpty(*streetIN)) {
	  enqueue(first(streetIN), streetWAIT);
	  dequeue(streetIN);
	}
	else {
	  // fail
	  1/0;
	  // this causes the ref-compiler to crash :(
	  //*null;
	}
  }
  
  printint(length(*streetIN));
  printint(length(*streetWAIT));
  printint(length(*streetOUT));
  printchar(10);
  
  // test
  test = (isSorted(reverse(*streetOUT)) ? 1 : 0);
  test |= (isEmpty(*streetIN) ? 1 : 0) << 1;
  test |= (isEmpty(*streetWAIT) ? 1 : 0) << 2;
  test |= ((length(*streetOUT) == 8) ? 1 : 0) << 3;
  
  assert (test == 15);
}
----
8
0
0

7
1
0

6
2
0

5
2
1

4
3
1

3
4
1

2
4
2

2
3
3

2
2
4

1
3
4

0
3
5

0
2
6

0
1
7

0
0
8

