/*
(
 (kind(CompileAndRun))
)
*/

extern int c0_runtime_print_char(int c);

// construct all permutations

bool isSolution(int[] a, int k, int n) {
  return k == n;
}

int constructCandidates(int[] a, int k, int n, int[] c) {
  int i, nc;
  int[] inPerm;
  
  inPerm = alloc_array(int, n + 1);
  
  for(i = 0; i <= n; i += 1) inPerm[i] = 0;
  for(i = 0; i < k; i += 1) inPerm[ a[i] ] = 1;
  
  nc = 0;
  for(i = 0; i <= n; i += 1) {
    if(inPerm[i] == 0) {
	  c[nc] = i;
	  nc += 1;
	}
  }
  
  return nc;
}

int processSolution(int[] a, int k) {
  int i;
  
  c0_runtime_print_char(91);
  c0_runtime_print_char(32);
  for(i = 1; i <= k; i += 1) {
      c0_runtime_print_char(48 + a[i]);
	  c0_runtime_print_char(32);
  }
  c0_runtime_print_char(93);
  c0_runtime_print_char(10);
  
  return 0;
}

// general backtracking algorithm

int backtrack(int[] a, int k, int n) {
  int[] c;
  int i, ncandidates, MAX_CANDIDATES, solutions;
  
  solutions = 0;
  MAX_CANDIDATES = n;
  c = alloc_array(int, MAX_CANDIDATES);
  
  if(isSolution(a, k, n)) {
    processSolution(a, k);
	solutions = 1;
  }
  else {
    k += 1;
	ncandidates = constructCandidates(a, k, n, c);
	for(i = 0; i < ncandidates; i += 1) {
	  a[k] = c[i];
	  solutions += backtrack(a, k, n);
	}
  }
  return solutions;
}

void main() {
  int[] a;
  int n;
  
  n = 3;
  a = alloc_array(int, n + 1);
  
  assert (backtrack(a, 0, n) == 6);
}
----
[ 1 2 3 ]
[ 1 3 2 ]
[ 2 1 3 ]
[ 2 3 1 ]
[ 3 1 2 ]
[ 3 2 1 ]
